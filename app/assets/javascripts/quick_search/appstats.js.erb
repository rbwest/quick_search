// Place all the behaviors and hooks related to the matching controller here.
// All this logic will automatically be available in application.js.
(function() {
  var AppStatsGlobals = {};
  AppStatsGlobals["#graph_line"] = {};
  AppStatsGlobals["#graph_module_clicks"] = {};
  AppStatsGlobals["#graph_result_clicks"] = {};
  AppStatsGlobals["#graph_top_searches"] = {};


  $(function () {
    $("#appstats-date-showhide").click(function () {
      $("#appstats-date-filter").toggle();
    });
  });


  $("document").ready(function() {
    if($("#graph_line").length){
      $.ajax({
          type: "GET",
          contentType: "application/json; charset=utf-8",
          url: "appstats/data",
          dataType: "json",
          success: function (sampleDataSet) {
            var dataMain = _.cloneDeep(sampleDataSet);
            var dataMini = _.cloneDeep(sampleDataSet);

            draw_graph_line(dataMain, false , 0);

            draw_graph_mini(dataMini[0] , "#mini0");
            document.getElementById("mini0").addEventListener("click" , function() { load_new_data(0); });
            document.getElementById("mini0").addEventListener("mouseover" , function() { d3.select("#mini0").select(".areaMini").style("fill" , "lightsteelblue"); });
            d3.select("#mini0").on("mouseout" , function() { d3.select("#mini0").select(".areaMini").style("fill" , "steelblue"); });
            draw_graph_mini(dataMini[1] , "#mini1");
            document.getElementById("mini1").addEventListener("click" , function() { load_new_data(1); });
            document.getElementById("mini1").addEventListener("mouseover" , function() { d3.select("#mini1").select(".areaMini").style("fill" , "lightsteelblue"); });
            document.getElementById("mini1").addEventListener("mouseout" , function() { d3.select("#mini1").select(".areaMini").style("fill" , "steelblue"); });
            draw_graph_mini(dataMini[2] , "#mini2");
            document.getElementById("mini2").addEventListener("click" , function() { load_new_data(2); });
            document.getElementById("mini2").addEventListener("mouseover" , function() { d3.select("#mini2").select(".areaMini").style("fill" , "lightsteelblue"); });
            document.getElementById("mini2").addEventListener("mouseout" , function() { d3.select("#mini2").select(".areaMini").style("fill" , "steelblue"); });
            draw_graph_mini(dataMini[3] , "#mini3");
            document.getElementById("mini3").addEventListener("click" , function() { load_new_data(3); });
            document.getElementById("mini3").addEventListener("mouseover" , function() { d3.select("#mini3").select(".areaMini").style("fill" , "lightsteelblue"); });
            document.getElementById("mini3").addEventListener("mouseout" , function() { d3.select("#mini3").select(".areaMini").style("fill" , "steelblue"); });
          },
          error: function (result) {
             error();
          }
      });
    }
    if($("#graph_module_clicks").length){
      $.ajax({
          type: "GET",
          contentType: "application/json; charset=utf-8",
          url: "data_module_clicks",
          dataType: "json",
          success: function (moduleDataSet) {
            var moduleData = _.cloneDeep(moduleDataSet);
            AppStatsGlobals["#graph_module_clicks"].OriginalData = moduleData;
            AppStatsGlobals["#graph_module_clicks"].Data = moduleData;
            AppStatsGlobals["#graph_module_clicks"].Height = 450;
            AppStatsGlobals["#graph_module_clicks"].Sort = 0;
            draw_graph_table("#graph_module_clicks");
          },
          error: function (result) {
             error();
          }
      });
    }
    if($("#graph_result_clicks").length){
      $.ajax({
          type: "GET",
          contentType: "application/json; charset=utf-8",
          url: "data_result_clicks",
          dataType: "json",
          success: function (resultDataSet) {
            var resultData = _.cloneDeep(resultDataSet);
            AppStatsGlobals["#graph_result_clicks"].OriginalData = resultData;
            AppStatsGlobals["#graph_result_clicks"].Data = resultData;
            AppStatsGlobals["#graph_result_clicks"].Sort = 0;
            AppStatsGlobals["#graph_result_clicks"].Height = 450;
            draw_graph_table("#graph_result_clicks");
          },
          error: function (result) {
             error();
          }
      });
    }
    if($("#graph_top_searches").length){
      $.ajax({
          type: "GET",
          contentType: "application/json; charset=utf-8",
          url: "data_top_searches",
          dataType: "json",
          success: function (searchDataSet) {
            var searchData = _.cloneDeep(searchDataSet);
            AppStatsGlobals["#graph_top_searches"].OriginalData = searchData;
            AppStatsGlobals["#graph_top_searches"].Data = searchData;
            AppStatsGlobals["#graph_top_searches"].Sort = 0;
            AppStatsGlobals["#graph_top_searches"].Height = 450;
            draw_graph_top_searches();
          },
          error: function (result) {
             error();
          }
      });
    }
  });

  function error() {
      console.log("Error retrieving data")
  }

  ////////////////////////////////////////// GENERAL STATISTICS //////////////////////////////////////////////////
  function draw_graph_line(dataShared , transitioning , index) {
    var transitioning = transitioning;
    var Globals = AppStatsGlobals["#graph_result_clicks"],
        svg = d3.select("#graph_line"),
        dataInt = dataShared[index],
        margin = {top: 20, right: 20, bottom: 110, left: 40},
        margin2 = {top: 430, right: 20, bottom: 30, left: 40},
        width = +svg.attr("width") - margin.left - margin.right,
        height = +svg.attr("height") - margin.top - margin.bottom,
        height2 = +svg.attr("height") - margin2.top - margin2.bottom,
        titles = ["Clicks" , "Serves" , "Sessions" , "Searches"]
        title = titles[index];

    // Parse dates into proper format
    var parseDate = d3.timeParse("%Y-%m-%d");

    dataInt.forEach( function (d) { 
      d.date = parseDate(d.date);
    });

    // Make scales
    var x = d3.scaleTime().range([0, width]),
        x2 = d3.scaleTime().range([0, width]),
        y = d3.scaleLinear().range([height, 0]),
        y2 = d3.scaleLinear().range([height2, 0]);

    // Set domains
    if (_.isEqual(undefined , Globals.Domain)) { x.domain(d3.extent(dataInt, function(d) { return d.date; })); }
    else { x.domain(Globals.Domain); }
    y.domain([0, d3.max(dataInt, function(d) { return d.count; })]);
    x2.domain(d3.extent(dataInt, function(d) { return d.date; }));
    y2.domain(y.domain());

    // Make axes
    var xAxis = d3.axisBottom(x),
        xAxis2 = d3.axisBottom(x2),
        yAxis = d3.axisLeft(y);

    // Make brush and zoom
    var brush = d3.brushX()
        .extent([[0, 0], [width, height2]])
        .on("brush end", brushed);

    var zoom = d3.zoom()
        .scaleExtent([1, 1000])
        .translateExtent([[0, 0], [width, height]])
        .extent([[0, 0], [width, height]])
        .on("zoom", zoomed);

    // Make areas
    var area = d3.area()
        .curve(d3.curveMonotoneX)
        .x(function(d) { return x(d.date); })
        .y0(height)
        .y1(function(d) { return y(d.count); });

    var area2 = d3.area()
        .curve(d3.curveMonotoneX)
        .x(function(d) { return x2(d.date); })
        .y0(height2)
        .y1(function(d) { return y2(d.count); });

    // Make focus
    var focusSelection = svg.selectAll(".focus").data([dataInt]);

    focusSelection.exit().remove();
    focusSelection.enter().append("g")
        .attr("class", "focus")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var focus = svg.select(".focus");

    // Make context
    var contextSelection = svg.selectAll(".context").data([dataInt]);

    contextSelection.exit().remove();
    contextSelection.enter().append("g")
       .attr("class", "context")
       .attr("transform", "translate(" + margin2.left + "," + margin2.top + ")");

    var context = svg.select(".context");

    // Make clip path
    var clipSelection = svg.selectAll("defs").data([dataInt]);

    clipSelection.exit().remove();
    clipSelection.enter().append("defs").append("clipPath")
        .attr("id", "clip")
    .append("rect")
       .attr("width", width)
       .attr("height", height);

    // Make focus x axis
    var xAxisSelection = focus.selectAll(".xAxis").data([dataInt]);

    xAxisSelection.transition().duration(750)
        .call(xAxis);
    xAxisSelection.exit().remove();
    xAxisSelection.enter().append("g")
        .attr("class", "xAxis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    // Make focus y axis
    var yAxisSelection = focus.selectAll(".yAxis").data([dataInt]);

    yAxisSelection.transition().duration(750)
        .call(yAxis);
    yAxisSelection.exit().remove();
    yAxisSelection.enter().append("g")
        .attr("class", "yAxis")
        .attr("transform", "translate(0,0)")
        .call(yAxis);

    // Make chart title
    var titleSelection = focus.selectAll(".chartTitle").data([dataInt]);

    titleSelection.transition().duration(325)
        .style("opacity", .00001)
      .transition()
        .text(title)
      .transition().duration(325)
        .style("opacity", 1);
    titleSelection.exit().remove();
    titleSelection.enter().append("text")
      .text(title)
      .attr("class" , "chartTitle")
      .attr("transform", "translate(" + (width/2) + "," + 30 + ")");

    // Make focus path
    var focusPathSelection = focus.selectAll(".area").data([dataInt]);

    focusPathSelection.datum(dataInt).transition().duration(750)
        .attr("d", area);
    focusPathSelection.exit().remove();
    focusPathSelection.enter().append("path")
      .datum(dataInt)
      .attr("class", "area")
      .attr("d", area);

    // Make context x axis
    var xAxis2Selection = context.selectAll(".xAxis").data([dataInt]);

    xAxis2Selection.transition().duration(500)
        .call(xAxis2);
    xAxis2Selection.exit().remove();
    xAxis2Selection.enter().append("g")
        .attr("class", "xAxis")
        .attr("transform", "translate(0," + height2 + ")")
        .call(xAxis2);

    // Make context path
    var contextPathSelection = context.selectAll(".area").data([dataInt]);

    contextPathSelection.datum(dataInt).transition().duration(750)
        .attr("d", area2);
    contextPathSelection.exit().remove();
    contextPathSelection.enter().append("path")
      .datum(dataInt)
      .attr("class", "area")
      .attr("d", area2);

    // Make brush container
    var brushSelection = context.selectAll(".brush").data([dataInt]);

    brushSelection.exit().remove();
    brushSelection.enter().append("g")
        .attr("class", "brush")
        .call(brush)
        .call(brush.move, x.range())
      .merge(brushSelection)
        .call(brush);

    // Make zoom container
    var zoomSelection = svg.selectAll(".zoom").data([dataInt]);

    zoomSelection.exit().remove();
    zoomSelection.enter().append("rect")
        .attr("class", "zoom")
        .attr("width", width)
        .attr("height", height)
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
      .merge(zoomSelection)
        .call(zoom);

    // Have to prevent zoom or brush temporarily for transitions to execute
    if(transitioning) { setTimeout(function() {transitioning=false} , 50); }

    function brushed() {
      if (!transitioning) {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "zoom") return;
        var s = d3.event.selection || x2.range();
        x.domain(s.map(x2.invert, x2));
        Globals.Domain = x.domain();
        focus.select(".area").attr("d", area);
        focus.select(".xAxis").call(xAxis);
        svg.select(".zoom").call(zoom.transform, d3.zoomIdentity
            .scale(width / (s[1] - s[0]))
            .translate(-s[0], 0));
      }
    }

    function zoomed() {
      if (!transitioning) {
        if (d3.event.sourceEvent && d3.event.sourceEvent.type === "brush") return;
        var t = d3.event.transform;
        x.domain(t.rescaleX(x2).domain());
        Globals.Domain = x.domain();
        focus.select(".area").attr("d", area);
        focus.select(".xAxis").call(xAxis);
        context.select(".brush").call(brush.move, x.range().map(t.invertX, t));
      }
    }

    function type(d) {
      d.date = parseDate(d.date);
      d.count = +d.count;
      return d;
    }
  }

  function load_new_data(index) {
    $.ajax({
        type: "GET",
        contentType: "application/json; charset=utf-8",
        url: "appstats/data",
        dataType: "json",
        success: function (updateDataSet) {
          var updateData = _.cloneDeep(updateDataSet);
          draw_graph_line(updateData , true , index);
        },
        error: function (result) {
           error();
        } 
    });
  }

  function draw_graph_mini(dataShared , id) {
    var svg = d3.select(id),
        dataInt = dataShared,
        margin = {top: 5, right: 5, bottom: 5, left: 5}
        width = +svg.attr("width") - margin.left - margin.right,
        height = +svg.attr("height") - margin.top - margin.bottom,
        title = "";
    if (id=="#mini0") { title="Clicks"; }
    if (id=="#mini1") { title="Serves"; }
    if (id=="#mini2") { title="Sessions"; }
    if (id=="#mini3") { title="Searches"; }

    var parseDate = d3.timeParse("%Y-%m-%d");

    dataInt.forEach( function (d) { 
      d.date = parseDate(d.date);
    });

    var x = d3.scaleTime().range([0, width]),
        y = d3.scaleLinear().range([height, 0]);

    x.domain(d3.extent(dataInt, function(d) { return d.date; }));
    y.domain([0, d3.max(dataInt, function(d) { return d.count; })]);

    var xAxis = d3.axisBottom(x),
        yAxis = d3.axisLeft(y);

    xAxis.tickSizeOuter(0);
    yAxis.tickSizeOuter(0);

    var area = d3.area()
      .curve(d3.curveMonotoneX)
      .x(function(d) { return x(d.date); })
      .y0(height)
      .y1(function(d) { return y(d.count); });

    svg.append("defs").append("clipPath")
      .attr("id", "clipMini")
    .append("rect")
      .attr("width", width)
      .attr("height", height);

    var focus = svg.append("g")
      .attr("class", "focus")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    focus.append("path")
        .datum(dataInt)
        .attr("class", "areaMini")
        .attr("d", area);

    focus.append("text")
        .text(title)
        .attr("class" , "chartTitle")
        .attr("transform", "translate(" + (width/2) + "," + (height/2) + ")");

    focus.append("g")
        .attr("class", "xAxis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis.ticks(0));

    focus.append("g")
        .attr("class", "yAxis")
        .call(yAxis.ticks(0));
  }
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  //////////////////////////////////////////// CLICKS OVERVIEW ///////////////////////////////////////////////////
  function draw_graph_table(id) {
    var Globals = AppStatsGlobals[id], 
        sortStates = [0 , 0 , 0 , 0]
        dataInt = Globals.Data,
        oldHeight = Globals.Height;

    sortStates[Globals.Sort] = 1;

    var svg = d3.select(id),         
        margin = {top: 20, right: 20, bottom: 20, left: 20},
        width = +svg.attr("width") - margin.left - margin.right,
        textPadding = 5,
        rowHeight = 35,
        barHeight = 25,
        rankWidth = width/8,
        categoryWidth = width/4,
        countWidth = 5*width/16,
        percentWidth = 5*width/16,
        barCenter = rankWidth + categoryWidth + countWidth,
        height = (dataInt.length+1) * rowHeight,
        childOffset = 25,
        triangleSpacing = 15,
        key = function(d) { return d.key; };

    svg.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("height" , height+margin.top+margin.bottom)
      .on("end" , function(d) { Globals.Height = height; } );

    var groupEnter = svg.selectAll("g").data([dataInt]).enter();

    groupEnter.append("g")
      .attr("class", "gAll");

    var gAll = svg.select(".gAll")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var x = d3.scaleLinear().rangeRound([0 , countWidth+percentWidth-200]);

    x.domain([0 , d3.max(dataInt , function(d) { return d.clickcount })]);

    var triangle = d3.symbol().type(d3.symbolTriangle).size(20);

    // Make header row //////////////////////////////////////////////////////////////////////////////
    var headGroupEnter = gAll.selectAll(".headRow").data([dataInt]).enter();

    headGroupEnter.append("g")
      .attr("class", "headRow");

    var gHead = gAll.select(".headRow")
      .attr("transform", "translate(0,0)");

    var headEnter = gHead.selectAll("rect").data([dataInt]).enter();

    headEnter.append("rect")
      .attr("class" , "darkBar")
      .attr("x" , 0)
      .attr("y" , 0)
      .attr("width" , width)
      .attr("height" , rowHeight);

    headEnter.append("text")
      .text("Rank")
      .attr("class" , "headText")
      .attr("transform", "translate(" + textPadding + "," + (rowHeight/2 + textPadding) + ")");

    headEnter.append("rect")
      .attr("class" , "sortRect")
      .attr("x" , (rankWidth - 2*triangleSpacing))
      .attr("y" , 0)
      .attr("width" , 2*triangleSpacing)
      .attr("height" , rowHeight)
      .on("click" , function(d) {
        if (Globals.Sort==0) { sort_table_data(id, 1); }
        else { sort_table_data(id, 0); }
      });

    headEnter.append("text")
      .text( function (d) {
        if (id=="#graph_module_clicks") { return "Module Clicked"; }
        else { return "Result Clicked"; }
      })
      .attr("class" , "headText")
      .attr("transform", "translate(" + (rankWidth + textPadding) + "," + (rowHeight/2 + textPadding) + ")");

    headEnter.append("rect")
      .attr("class" , "sortRect")
      .attr("x" , (rankWidth + categoryWidth - 2*triangleSpacing))
      .attr("y" , 0)
      .attr("width" , 2*triangleSpacing)
      .attr("height" , rowHeight)
      .on("click" , function(d) {
        if (Globals.Sort==2) { sort_table_data(id, 3); }
        else { sort_table_data(id, 2); }
      });

    headEnter.append("text")
      .text("Count")
      .attr("class" , "headText")
      .attr("transform", "translate(" + (rankWidth + categoryWidth + textPadding) + "," + (rowHeight/2 + textPadding) + ")");

    headEnter.append("text")
      .text("Percent")
      .attr("class" , "percentText")
      .attr("transform", "translate(" + (rankWidth + categoryWidth + countWidth + percentWidth - textPadding) + "," + (rowHeight/2 + textPadding) + ")");

    var triangles = gHead.selectAll("path").data(sortStates);

    triangles.enter().append("path")
      .attr("d" , triangle)
      .attr("pointer-events", "none")
      .attr("transform" , function(d , i) { 
        if (i==0)      { return "translate(" + (rankWidth - triangleSpacing) + "," + (rowHeight/2 - textPadding) + ")"; }
        else if (i==1) { return "translate(" + (rankWidth - triangleSpacing) + "," + (rowHeight/2 + textPadding) + ") rotate(180)"; }
        else if (i==2) { return "translate(" + (rankWidth + categoryWidth - triangleSpacing) + "," + (rowHeight/2 - textPadding) + ")"; }
        else if (i==3) { return "translate(" + (rankWidth + categoryWidth - triangleSpacing) + "," + (rowHeight/2 + textPadding) + ") rotate(180)"; }
      })
    .merge(triangles)
      .transition().duration(500)
      .attr("fill" , function (d , i) { 
        if (d) { return "steelblue"; }
        else { return "lightsteelblue"; }
      });

    // Make data rows ////////////////////////////////////////////////////////////////////////////////
    var dataGroup = gAll.selectAll(".dataRow").data([dataInt]);

    dataGroup.enter().append("g")
      .attr("class", "dataRow");

    var dataRows = gAll.select(".dataRow")
      .attr("transform", "translate(0,0)");

    // Make background rects
    var dataRects = dataRows.selectAll(".darkBar, .lightBar").data(dataInt, key);

    dataRects.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("y" , function(d, i) { return (i+1)*rowHeight; });
    dataRects.exit().remove();
    dataRects.enter().append("rect")
      .attr("class" , function(d, i) { 
        if(d.parent) { return "lightBar"; }
        else { return "darkBar"; }
      })
      .attr("x" , 0)
      .attr("y" , function(d, i) { return (i+1)*rowHeight; })
      .attr("width" , width)
      .attr("height" , rowHeight);

    // Make rank text
    var dataRanks = dataRows.selectAll(".dataRank").data(dataInt, key);

    dataRanks.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("transform", function(d, i) { 
        if (!d.parent) { return "translate(" + textPadding + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; }
        else { return "translate(" + (textPadding + childOffset) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; }
      });
    dataRanks.exit().transition().duration(500)
      .style("opacity", .000001)
      .remove();
    dataRanks.enter().append("text")
      .style("opacity", .000001)
      .text(function(d) { return d.rank; })
      .attr("class" , "dataRank")
      .attr("transform", function(d, i) { 
        if (!d.parent) { return "translate(" + textPadding + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; }
        else { return "translate(" + (textPadding + childOffset) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; }
      })
    .transition().delay(750).duration(500)
      .style("opacity" , 1);

    // Make action text
    var dataActions = dataRows.selectAll(".dataAction").data(dataInt, key);

    dataActions.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("transform", function(d, i) { 
        if (!d.parent) { return "translate(" + (rankWidth + textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")";  }
        else { return "translate(" + (rankWidth + textPadding + childOffset) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; }
      });
    dataActions.exit().transition().duration(500)
      .style("opacity", .000001)
      .remove();
    dataActions.enter().append("text")
      .style("opacity", .000001)
      .text(function(d) { 
        if (d.label.length>20) { return d.label.slice(0,20) + "..."; }
        else { return d.label; } 
      })
      .attr("class" , "dataAction")
      .attr("transform", function(d, i) { 
        if (!d.parent) { return "translate(" + (rankWidth + textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")";  }
        else { return "translate(" + (rankWidth + textPadding + childOffset) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; }
      })
    .transition().delay(750).duration(500)
      .style("opacity" , 1);

    // Make click text
    var dataClicks = dataRows.selectAll(".dataClick").data(dataInt, key);

    dataClicks.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("transform", function(d, i) { 
        if (!d.parent) { return "translate(" + (rankWidth + categoryWidth + textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")";  }
        else { return "translate(" + (rankWidth + categoryWidth + textPadding + childOffset) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; }
      });
    dataClicks.exit().transition().duration(500)
      .style("opacity", .000001)
      .remove();
    dataClicks.enter().append("text")
      .style("opacity", .000001)
      .text(function(d) { return d.clickcount; })
      .attr("class" , "dataClick")
      .attr("transform", function(d, i) { 
        if (!d.parent) { return "translate(" + (rankWidth + categoryWidth + textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")";  }
        else { return "translate(" + (rankWidth + categoryWidth + textPadding + childOffset) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; }
      })
    .transition().delay(750).duration(500)
      .style("opacity" , 1);

    // Make percent text
    var dataPercents = dataRows.selectAll(".dataPercent").data(dataInt, key);

    dataPercents.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("transform", function(d, i) { 
        if (!d.parent) { return "translate(" + (rankWidth + categoryWidth + countWidth + percentWidth - textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")";  }
        else { return "translate(" + (rankWidth + categoryWidth + countWidth + percentWidth - textPadding - childOffset) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; }
      });
    dataPercents.exit().transition().duration(500)
      .style("opacity", .000001)
      .remove();
    dataPercents.enter().append("text")
      .style("opacity", .000001)
      .text(function(d) { return d.percentage + "%"; })
      .attr("class" , "dataPercent")
      .attr("transform", function(d, i) { 
        if (!d.parent) { return "translate(" + (rankWidth + categoryWidth + countWidth + percentWidth - textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")";  }
        else { return "translate(" + (rankWidth + categoryWidth + countWidth + percentWidth - textPadding - childOffset) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; }
      })
    .transition().delay(750).duration(500)
      .style("opacity" , 1);

    // Make data bars
    var dataBars = dataRows.selectAll(".dataBar, .lightDataBar").data(dataInt, key);

    dataBars.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("y", function(d, i) { return (i+1)*rowHeight + (rowHeight-barHeight)/2; });
    dataBars.exit().transition().duration(500)
      .attr("x", barCenter)
      .attr("width", 0)
      .remove();
    dataBars.enter().append("rect")
      .attr("class", function (d) { 
        if (!d.parent) { return "dataBar"; }
        else { return "lightDataBar"; }
      })
      .attr("x", function(d) { return barCenter; } )
      .attr("y", function(d, i) { return (i+1)*rowHeight + (rowHeight-barHeight)/2; })
      .attr("width", function(d) { return 0; })
      .attr("height", barHeight )
      .style("cursor", function(d) { 
        if (id=="#graph_module_clicks" && !d.parent) { return "pointer"; }
        else { return "auto"; }
      })
      .on("click" , function(d) { 
        if(id=="#graph_module_clicks" && !d.expanded && !d.parent) { 
          d.expanded = 1;
          load_details(d.label, id);
        }
        else if (id=="#graph_module_clicks" && d.expanded && !d.parent) {
          d.expanded = 0;
          remove_details(d.label, id);
        }
      })
    .transition().delay(750).duration(500)
      .attr("x", function(d) { return barCenter - x(d.clickcount)/2; } )
      .attr("width", function(d) { return x(d.clickcount); });

    // Add borders ///////////////////////////////////////////////////////////////////////////////////
    var lightBorder = gAll.selectAll(".lightBorder").data([dataInt]);

    lightBorder.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("height", height);
    lightBorder.exit().remove();
    lightBorder.enter().append("rect")
      .attr("class", "lightBorder")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", width)
      .attr("height", height);;

    var darkBorder = gAll.selectAll(".darkBorder").data([dataInt]);

    darkBorder.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("height", height-rowHeight);
    darkBorder.exit().remove();
    darkBorder.enter().append("rect")
      .attr("class", "darkBorder")
      .attr("x", 0)
      .attr("y", rowHeight)
      .attr("width", width)
      .attr("height", height-rowHeight);
  }

  function load_details(category, id) {
    var updateData = _.cloneDeep(AppStatsGlobals[id].Data);
    $.ajax({
        type: "GET",
        contentType: "application/json; charset=utf-8",
        url: "data_module_details",
        dataType: "json",
        data: {"category":category},
        success: function (detailSet) {
          var detailData = _.cloneDeep(detailSet);
          var index = _.findIndex(updateData, {"label":category});
          updateData = _.concat(_.slice(updateData,0,index+1) , detailData , _.slice(updateData , index+1 , updateData.length));
          
          AppStatsGlobals[id].Data = updateData;
          draw_graph_table(id);
        },
        error: function (result) {
           error();
        }
    });
  }

  function remove_details(category, id) {
    var updateData = _.cloneDeep(AppStatsGlobals[id].Data);
    console.log(updateData);
    var startIndex = _.findIndex(updateData, {"label":category});
    var endIndex = startIndex+1;
    while (endIndex<updateData.length && updateData[endIndex].parent) { endIndex++; }
    console.log("start=" + startIndex + ", end=" + endIndex);
    updateData = _.concat(_.slice(updateData,0,startIndex+1), _.slice(updateData , endIndex , updateData.length));
    console.log(updateData);
    
    AppStatsGlobals[id].Data = updateData;
    draw_graph_table(id);
  }

  function sort_table_data(id, sort) {
    if (AppStatsGlobals[id].Data.length != AppStatsGlobals[id].OriginalData.length) {     // If details are present, those must be removed first
      // Go back to original data set (no details)
      switch(AppStatsGlobals[id].Sort) {
        case 0: // rank asc
          AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(a.rank,b.rank); } );
          break;
        case 1: // rank desc
          AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(b.rank,a.rank); } ); 
          break;
        case 2: // label asc
          AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(a.label,b.label); } ); 
          break;
        case 3: // label desc
          AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(b.label,a.label); } ); 
          break;
      }

      // Apply new sort after 750 mS (time for details to be removed)
      switch(sort) {
        case 0: // rank asc
          setTimeout(function() {
            AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(a.rank,b.rank); } );
            draw_graph_table(id);
          } , 750);
          break;
        case 1: // rank desc
          setTimeout(function() {
            AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(b.rank,a.rank); } ); 
            draw_graph_table(id);
          } , 750);
          break;
        case 2: // label asc
          setTimeout(function() {
            AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(a.label,b.label); } ); 
            draw_graph_table(id);
          } , 750);
          break;
        case 3: // label desc
          setTimeout(function() {
            AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(b.label,a.label); } ); 
            draw_graph_table(id);
          } , 750);
          break;
      }
    }
    else {     // Otherwise, you can just resort the data
      switch(sort) {
        case 0: // rank asc
          AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(a.rank,b.rank); } );
          break;
        case 1: // rank desc
          AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(b.rank,a.rank); } ); 
          break;
        case 2: // label asc
          AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(a.label,b.label); } ); 
          break;
        case 3: // label desc
          AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(b.label,a.label); } ); 
          break;
      }
    }

    // Update global sort
    AppStatsGlobals[id].Sort = sort;
    draw_graph_table(id);
  }
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////

  ///////////////////////////////////////////// TOP SEARCHES /////////////////////////////////////////////////////
  function draw_graph_top_searches() {
    var Globals = AppStatsGlobals["#graph_top_searches"], 
        sortStates = [0 , 0 , 0 , 0]
        dataInt = Globals.Data,
        oldHeight = Globals.Height;

    sortStates[Globals.Sort] = 1;

    var svg = d3.select("#graph_top_searches"),         
        margin = {top: 20, right: 20, bottom: 20, left: 20},
        width = +svg.attr("width") - margin.left - margin.right,
        textPadding = 5,
        rowHeight = 35,
        barHeight = 25,
        rankWidth = 2*width/16,
        categoryWidth = 4*width/16,
        countWidth = 2*width/16,
        percentWidth = 3*width/16,
        cumPercentWidth = 5*width/16,
        percBarCenter = rankWidth + categoryWidth + countWidth,
        cumPercBarStart = rankWidth + categoryWidth + countWidth + percentWidth + 3*textPadding + 13*d3.max(dataInt, function(d) { return d.cum_percentage.toString().length; }),
        height = (dataInt.length+1) * rowHeight,
        childOffset = 25,
        triangleSpacing = 15,
        key = function(d) { return d.key; };

    svg.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("height" , height+margin.top+margin.bottom)
      .on("end" , function(d) { Globals.Height = height; } );

    var groupEnter = svg.selectAll("g").data([dataInt]).enter();

    groupEnter.append("g")
      .attr("class", "gAll");

    var gAll = svg.select(".gAll")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var percScale = d3.scaleLinear().rangeRound([0 , countWidth+percentWidth-100]);

    percScale.domain([0 , d3.max(dataInt , function(d) { return d.cum_percentage })]);

    var cumPercScale = d3.scaleLinear().rangeRound([0 , countWidth+percentWidth-100]);

    cumPercScale.domain([0 , d3.max(dataInt , function(d) { return d.cum_percentage })]);

    var triangle = d3.symbol().type(d3.symbolTriangle).size(20);

    // Make header row //////////////////////////////////////////////////////////////////////////////
    var headGroupEnter = gAll.selectAll(".headRow").data([dataInt]).enter();

    headGroupEnter.append("g")
      .attr("class", "headRow");

    var gHead = gAll.select(".headRow")
      .attr("transform", "translate(0,0)");

    var headEnter = gHead.selectAll("rect").data([dataInt]).enter();

    headEnter.append("rect")
      .attr("class" , "darkBar")
      .attr("x" , 0)
      .attr("y" , 0)
      .attr("width" , width)
      .attr("height" , rowHeight);

    headEnter.append("text")
      .text("Rank")
      .attr("class" , "headText")
      .attr("transform", "translate(" + textPadding + "," + (rowHeight/2 + textPadding) + ")");

    headEnter.append("rect")
      .attr("class" , "sortRect")
      .attr("x" , (rankWidth - 2*triangleSpacing))
      .attr("y" , 0)
      .attr("width" , 2*triangleSpacing)
      .attr("height" , rowHeight)
      .on("click" , function(d) {
        if (Globals.Sort==0) { sort_search_data(1); }
        else { sort_search_data(0); }
      });

    headEnter.append("text")
      .text("Query")
      .attr("class" , "headText")
      .attr("transform", "translate(" + (rankWidth + textPadding) + "," + (rowHeight/2 + textPadding) + ")");

    headEnter.append("rect")
      .attr("class" , "sortRect")
      .attr("x" , (rankWidth + categoryWidth - 2*triangleSpacing))
      .attr("y" , 0)
      .attr("width" , 2*triangleSpacing)
      .attr("height" , rowHeight)
      .on("click" , function(d) {
        if (Globals.Sort==2) { sort_search_data(3); }
        else { sort_search_data(2); }
      });

    headEnter.append("text")
      .text("Count")
      .attr("class" , "headText")
      .attr("transform", "translate(" + (rankWidth + categoryWidth + textPadding) + "," + (rowHeight/2 + textPadding) + ")");

    headEnter.append("text")
      .text("Percent")
      .attr("class" , "percentText")
      .attr("transform", "translate(" + (rankWidth + categoryWidth + countWidth + percentWidth - textPadding) + "," + (rowHeight/2 + textPadding) + ")");

    headEnter.append("text")
      .text("Cumulative Percent")
      .attr("class", "headText")
      .attr("transform", "translate(" + (rankWidth + categoryWidth + countWidth + percentWidth + 3*textPadding) + "," + (rowHeight/2 + textPadding) + ")");


    var triangles = gHead.selectAll("path").data(sortStates);

    triangles.enter().append("path")
      .attr("d" , triangle)
      .attr("pointer-events", "none")
      .attr("transform" , function(d , i) { 
        if (i==0)      { return "translate(" + (rankWidth - triangleSpacing) + "," + (rowHeight/2 - textPadding) + ")"; }
        else if (i==1) { return "translate(" + (rankWidth - triangleSpacing) + "," + (rowHeight/2 + textPadding) + ") rotate(180)"; }
        else if (i==2) { return "translate(" + (rankWidth + categoryWidth - triangleSpacing) + "," + (rowHeight/2 - textPadding) + ")"; }
        else if (i==3) { return "translate(" + (rankWidth + categoryWidth - triangleSpacing) + "," + (rowHeight/2 + textPadding) + ") rotate(180)"; }
      })
    .merge(triangles)
      .transition().duration(500)
      .attr("fill" , function (d , i) { 
        if (d) { return "steelblue"; }
        else { return "lightsteelblue"; }
      });

    // Make data rows ////////////////////////////////////////////////////////////////////////////////
    var dataGroup = gAll.selectAll(".dataRow").data([dataInt]);

    dataGroup.enter().append("g")
      .attr("class", "dataRow");

    var dataRows = gAll.select(".dataRow")
      .attr("transform", "translate(0,0)");

    // Make background rects
    var dataRects = dataRows.selectAll(".darkBar, .lightBar").data(dataInt, key);

    dataRects.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("y" , function(d, i) { return (i+1)*rowHeight; });
    dataRects.exit().remove();
    dataRects.enter().append("rect")
      .attr("class" , function(d, i) { 
        if(d.parent) { return "lightBar"; }
        else { return "darkBar"; }
      })
      .attr("x" , 0)
      .attr("y" , function(d, i) { return (i+1)*rowHeight; })
      .attr("width" , width)
      .attr("height" , rowHeight);

    // Make rank text
    var dataRanks = dataRows.selectAll(".dataRank").data(dataInt, key);

    dataRanks.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("transform", function(d,i) { return "translate(" + textPadding + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; } );
    dataRanks.exit().transition().duration(500)
      .style("opacity", .000001)
      .remove();
    dataRanks.enter().append("text")
      .style("opacity", .000001)
      .text(function(d) { return d.rank; })
      .attr("class" , "dataRank")
      .attr("transform",  function(d,i) { return "translate(" + textPadding + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; } )
    .transition().delay(750).duration(500)
      .style("opacity" , 1);

    // Make action text
    var dataActions = dataRows.selectAll(".dataAction").data(dataInt, key);

    dataActions.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("transform", function(d,i) { return "translate(" + (rankWidth + textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; } );
    dataActions.exit().transition().duration(500)
      .style("opacity", .000001)
      .remove();
    dataActions.enter().append("text")
      .style("opacity", .000001)
      .text(function(d) { 
        if (d.label.length>20) { return d.label.slice(0,20) + "..."; }
        else { return d.label; } 
      })
      .attr("class" , "dataAction")
      .attr("transform", function(d,i) { return "translate(" + (rankWidth + textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; } )
    .transition().delay(750).duration(500)
      .style("opacity" , 1);

    // Make click text
    var dataClicks = dataRows.selectAll(".dataClick").data(dataInt, key);

    dataClicks.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("transform", function(d,i) { return "translate(" + (rankWidth + categoryWidth + textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; } );
    dataClicks.exit().transition().duration(500)
      .style("opacity", .000001)
      .remove();
    dataClicks.enter().append("text")
      .style("opacity", .000001)
      .text(function(d) { return d.count; })
      .attr("class" , "dataClick")
      .attr("transform", function(d,i) { return "translate(" + (rankWidth + categoryWidth + textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; } )
    .transition().delay(750).duration(500)
      .style("opacity" , 1);

    // Make percent text
    var dataPercents = dataRows.selectAll(".dataPercent").data(dataInt, key);

    dataPercents.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("transform", function(d,i) { return "translate(" + (rankWidth + categoryWidth + countWidth + percentWidth - textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; } );
    dataPercents.exit().transition().duration(500)
      .style("opacity", .000001)
      .remove();
    dataPercents.enter().append("text")
      .style("opacity", .000001)
      .text(function(d) { return d.percentage + "%"; })
      .attr("class" , "dataPercent")
      .attr("transform", function(d,i) { return "translate(" + (rankWidth + categoryWidth + countWidth + percentWidth - textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; } )
    .transition().delay(750).duration(500)
      .style("opacity" , 1);

    // Make click text
    var dataCumPercents = dataRows.selectAll(".dataCumPercent").data(dataInt, key);

    dataCumPercents.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("transform", function(d,i) { return "translate(" + (rankWidth + categoryWidth + countWidth + percentWidth + 3*textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; } );
    dataCumPercents.exit().transition().duration(500)
      .style("opacity", .000001)
      .remove();
    dataCumPercents.enter().append("text")
      .style("opacity", .000001)
      .text(function(d) { return d.cum_percentage + "%"; })
      .attr("class" , "dataCumPercent")
      .attr("transform", function(d,i) { return "translate(" + (rankWidth + categoryWidth + countWidth + percentWidth + 3*textPadding) + "," + Math.floor((i+1)*rowHeight + rowHeight/2 + textPadding) + ")"; } )
    .transition().delay(750).duration(500)
      .style("opacity" , 1);

    // Make perc bars
    var percBars = dataRows.selectAll(".percBar").data(dataInt, key);

    percBars.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("y", function(d, i) { return (i+1)*rowHeight + (rowHeight-barHeight)/2; });
    percBars.exit().transition().duration(500)
      .attr("x", percBarCenter)
      .attr("width", 0)
      .remove();
    percBars.enter().append("rect")
      .attr("class", "percBar")
      .attr("x", function(d) { return percBarCenter; } )
      .attr("y", function(d, i) { return (i+1)*rowHeight + (rowHeight-barHeight)/2; })
      .attr("width", function(d) { return 0; })
      .attr("height", barHeight )
    .transition().delay(750).duration(500)
      .attr("x", function(d) { return percBarCenter - percScale(d.percentage)/2; } )
      .attr("width", function(d) { return percScale(d.percentage); });

    // Make cumulative perc bars
    var cumPercBar = dataRows.selectAll(".cumPercBar").data(dataInt, key);

    cumPercBar.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("y", function(d, i) { return (i+1)*rowHeight + (rowHeight-barHeight)/2; });
    cumPercBar.exit().transition().duration(500)
      .attr("width", 0)
      .remove();
    cumPercBar.enter().append("rect")
      .attr("class", "cumPercBar")
      .attr("x", function(d) { return cumPercBarStart; } )
      .attr("y", function(d, i) { return (i+1)*rowHeight + (rowHeight-barHeight)/2; })
      .attr("width", function(d) { return 0; })
      .attr("height", barHeight )
    .transition().delay(750).duration(500)
      .attr("width", function(d) { return cumPercScale(d.cum_percentage); });

    // Add borders ///////////////////////////////////////////////////////////////////////////////////
    var lightBorder = gAll.selectAll(".lightBorder").data([dataInt]);

    lightBorder.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("height", height);
    lightBorder.exit().remove();
    lightBorder.enter().append("rect")
      .attr("class", "lightBorder")
      .attr("x", 0)
      .attr("y", 0)
      .attr("width", width)
      .attr("height", height);;

    var darkBorder = gAll.selectAll(".darkBorder").data([dataInt]);

    darkBorder.transition().delay( function(d) {
        if (oldHeight > height) { return 500; }
        else { return 0; }
      })
      .duration(750)
      .attr("height", height-rowHeight);
    darkBorder.exit().remove();
    darkBorder.enter().append("rect")
      .attr("class", "darkBorder")
      .attr("x", 0)
      .attr("y", rowHeight)
      .attr("width", width)
      .attr("height", height-rowHeight);
  }

  function sort_search_data(sort) {
    var id = "#graph_top_searches";
    console.log("Before Sort:");
    console.log(AppStatsGlobals[id].OriginalData);
    switch(sort) {
      case 0: // rank asc
        AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(a.rank,b.rank); } );
        break;
      case 1: // rank desc
        AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(b.rank,a.rank); } ); 
        break;
      case 2: // label asc
        AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(a.label,b.label); } ); 
        break;
      case 3: // label desc
        AppStatsGlobals[id].Data = AppStatsGlobals[id].OriginalData.sort( function(a,b) { return d3.ascending(b.label,a.label); } ); 
        break;
    }
    console.log("After Sort:");
    console.log(AppStatsGlobals[id].OriginalData);

    // Update global sort
    AppStatsGlobals[id].Sort = sort;
    draw_graph_top_searches();
    // setTimeout( function(d) { draw_graph_top_searches(); }, 500);
  }
  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////

})();